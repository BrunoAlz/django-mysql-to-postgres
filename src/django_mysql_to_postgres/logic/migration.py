# src/django_mysql_to_postgres/logic/migration.py
"""
Core logic for executing the data migration between two databases.

This module handles the physical process of connecting to the databases,
cleaning the destination tables, and transferring data row by row,
based on a pre-generated migration plan.
"""
from typing import Callable, Dict, List, Optional

from django.apps import apps
from django.db import connections, models

try:
    from psycopg2 import errors as psycopg2_errors
    UNDEFINED_TABLE_ERROR = psycopg2_errors.UndefinedTable
except ImportError:
    UNDEFINED_TABLE_ERROR = Exception


def _default_callback(level: str, message: str):
    """A no-op callback function to avoid checking for None."""
    pass


def execute_migration(
    plan: Dict[str, List[str]],
    source_db_alias: str,
    destination_db_alias: str,
    progress_callback: Optional[Callable[[str, str], None]] = None,
):
    """
    Executes the full data migration process based on the provided plan.

    This function orchestrates the cleaning of the destination database,
    the transfer of data for regular models, and the transfer of data for
    ManyToMany relationships. It is designed to be robust, handling potential
    missing tables and reporting progress via a callback.

    Args:
        plan: The migration plan dictionary generated by `analysis.py`.
        source_db_alias: The Django database alias for the source DB.
        destination_db_alias: The Django database alias for the destination DB.
        progress_callback: An optional function to call for progress updates.
    """
    callback = progress_callback or _default_callback
    migration_order = plan.get("migration_order", [])

    if not migration_order:
        callback("WARNING", "Migration plan is empty. Nothing to migrate.")
        return

    with connections[destination_db_alias].cursor() as cursor:
        callback("INFO", "Disabling triggers and foreign keys on destination DB...")
        cursor.execute("SET session_replication_role = 'replica';")

        callback("INFO", "--- PHASE 1: Cleaning destination tables... ---")
        for model_label in reversed(migration_order):
            try:
                model = apps.get_model(model_label)
                table_name = model._meta.db_table
                callback("INFO", f"Cleaning table: {table_name}")
                cursor.execute(
                    f'TRUNCATE TABLE "{table_name}" RESTART IDENTITY CASCADE;')
            except UNDEFINED_TABLE_ERROR:
                callback(
                    "WARNING", f"Table '{table_name}' not found in destination. Skipping cleanup.")
            except Exception as e:
                callback(
                    "ERROR", f"Unexpected error cleaning {table_name}: {e}")
                cursor.execute("SET session_replication_role = 'origin';")
                raise

        callback("INFO", "\n--- PHASE 2: Migrating model data... ---")
        migrated_models_classes = []
        for model_label in migration_order:
            model = apps.get_model(model_label)
            migrated_models_classes.append(model)

            callback(
                "INFO", f"\nMigrating {model._meta.verbose_name_plural}...")

            original_states = {}
            for field in model._meta.local_fields:
                if isinstance(field, (models.DateTimeField, models.DateField)):
                    if field.auto_now or field.auto_now_add:
                        original_states[field.name] = {
                            "auto_now": field.auto_now,
                            "auto_now_add": field.auto_now_add,
                        }
                        field.auto_now = False
                        field.auto_now_add = False

            try:
                source_items = list(model.objects.using(source_db_alias).all())
                count = len(source_items)

                if count == 0:
                    callback("INFO", "No items to migrate.")
                    continue

                callback(
                    "INFO", f"Found {count} items. Inserting into destination...")
                model.objects.using(destination_db_alias).bulk_create(
                    source_items, batch_size=1000)
                callback("SUCCESS", "Success!")

            except Exception as e:
                if ("1146" in str(e)) or ("UndefinedTable" in str(e.__class__.__name__)):
                    callback(
                        "WARNING", f"Table for '{model_label}' not found. Skipping.")
                else:
                    callback(
                        "ERROR", f"Error during data migration for {model_label}: {e}")
                    cursor.execute("SET session_replication_role = 'origin';")
                    raise
            finally:
                if original_states:
                    for field in model._meta.local_fields:
                        if field.name in original_states:
                            field.auto_now = original_states[field.name]['auto_now']
                            field.auto_now_add = original_states[field.name]['auto_now_add']
                    callback(
                        "INFO", f"Restored auto-timestamp fields for {model_label}")

        callback("INFO", "\n--- PHASE 3: Migrating ManyToMany relationships... ---")
        m2m_model_labels = plan.get("m2m_through_models", [])

        if not m2m_model_labels:
            callback("INFO", "No custom ManyToMany models to migrate.")
        else:
            for model_label in m2m_model_labels:
                callback("INFO", f"\nProcessing M2M table: {model_label}")
                try:
                    m2m_model = apps.get_model(model_label)
                    m2m_relations = list(
                        m2m_model.objects.using(source_db_alias).all())

                    if m2m_relations:
                        m2m_model.objects.using(destination_db_alias).bulk_create(
                            m2m_relations, batch_size=2000
                        )
                        callback(
                            "SUCCESS", f"Success: {len(m2m_relations)} relationships migrated for {model_label}.")
                    else:
                        callback(
                            "INFO", f"No relationships to migrate for {model_label}.")
                except Exception as e:
                    callback(
                        "WARNING", f"Could not migrate M2M for {model_label}: {e}")

        callback(
            "INFO", "\n--- Finalizing: Re-enabling triggers and resetting sequences... ---")
        cursor.execute("SET session_replication_role = 'origin';")

        for model in migrated_models_classes:
            try:
                table_name = model._meta.db_table
                pk_name = model._meta.pk.name
                if isinstance(model._meta.pk, (models.AutoField, models.BigAutoField)):
                    sql = f"""SELECT setval(pg_get_serial_sequence('"{table_name}"', '{pk_name}'), COALESCE(MAX("{pk_name}"), 1), MAX("{pk_name}") IS NOT NULL) FROM "{table_name}";"""
                    cursor.execute(sql)
            except (Exception, UNDEFINED_TABLE_ERROR):
                pass

    callback("SUCCESS", "\n\nMigration process completed successfully!")
